<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Encoder - Secure Encoding</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: #e0e0e0;
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1100px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, #00b4db, #0083b0);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .subtitle {
            color: #a0a0a0;
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            padding: 25px;
            margin-bottom: 25px;
            transition: transform 0.3s;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .input-section, .output-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        label {
            font-weight: 600;
            color: #00b4db;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            font-size: 1rem;
            resize: vertical;
            min-height: 150px;
            transition: all 0.3s;
            background: rgba(0, 0, 0, 0.2);
            color: #e0e0e0;
        }
        
        textarea:focus {
            outline: none;
            border-color: #00b4db;
            box-shadow: 0 0 0 3px rgba(0, 180, 219, 0.2);
        }
        
        .options-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        select, button, input {
            padding: 12px 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s;
            background: rgba(0, 0, 0, 0.2);
            color: #e0e0e0;
        }
        
        select {
            flex: 1;
            min-width: 200px;
            cursor: pointer;
        }
        
        select:focus {
            outline: none;
            border-color: #00b4db;
        }
        
        button {
            background: linear-gradient(to right, #00b4db, #0083b0);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 25px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .action-buttons button {
            flex: 1;
            min-width: 160px;
        }
        
        .copy-btn {
            background: linear-gradient(to right, #11998e, #38ef7d);
        }
        
        .download-btn {
            background: linear-gradient(to right, #654ea3, #eaafc8);
        }
        
        .clear-btn {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
        }
        
        .file-upload {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        
        .file-input {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-label {
            display: block;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-input-label:hover {
            background-color: rgba(0, 0, 0, 0.3);
            border-color: #00b4db;
        }
        
        .file-name {
            font-size: 0.9rem;
            color: #a0a0a0;
        }
        
        .result-container {
            position: relative;
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .char-count {
            font-size: 0.9rem;
            color: #a0a0a0;
        }
        
        .result {
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            min-height: 150px;
            word-break: break-all;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            background: linear-gradient(to right, #11998e, #38ef7d);
            color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
            z-index: 1000;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .notification.error {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
        }
        
        .encoding-info {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #a0a0a0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            color: #a0a0a0;
            font-size: 0.9rem;
        }
        
        .security-note {
            background: rgba(255, 255, 255, 0.08);
            color: #e0e0e0;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 0.85rem;
            border-left: 4px solid #00b4db;
        }
        
        .custom-key {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .key-input {
            flex: 1;
        }
        
        .generate-key {
            background: linear-gradient(to right, #8e2de2, #4a00e0);
            padding: 10px 15px;
            white-space: nowrap;
        }
        
        @media (max-width: 768px) {
            .options-row {
                flex-direction: column;
            }
            
            select, button, input {
                width: 100%;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .custom-key {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-code"></i> Custom Encoder</h1>
            <p class="subtitle">Create encoded messages that can only be decoded with this tool using custom algorithms</p>
        </header>
        
        <main>
            <div class="card input-section">
                <div class="input-group">
                    <label for="input-text"><i class="fas fa-keyboard"></i> Input Text</label>
                    <textarea id="input-text" placeholder="Enter text to encode or decode..."></textarea>
                </div>
                
                <div class="file-upload">
                    <label><i class="fas fa-file-upload"></i> Or Upload a File</label>
                    <div class="file-input-container">
                        <input type="file" id="file-input" class="file-input">
                        <div class="file-input-label">
                            <span>Click to select a file or drag and drop</span>
                        </div>
                    </div>
                    <div class="file-name" id="file-name">No file selected</div>
                </div>
                
                <div class="options-row">
                    <div class="input-group" style="flex: 1;">
                        <label for="encoding-type"><i class="fas fa-code"></i> Encoding Type</label>
                        <select id="encoding-type">
                            <option value="custom1">Custom Algorithm 1</option>
                            <option value="custom2">Custom Algorithm 2</option>
                            <option value="custom3">Custom Algorithm 3</option>
                            <option value="matrix">Matrix Encoding</option>
                            <option value="shadow">Shadow Code</option>
                        </select>
                    </div>
                    
                    <div class="input-group" style="flex: 1;">
                        <label for="action-type"><i class="fas fa-cogs"></i> Action</label>
                        <select id="action-type">
                            <option value="encode">Encode</option>
                            <option value="decode">Decode</option>
                        </select>
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="custom-key"><i class="fas fa-key"></i> Custom Key (Optional)</label>
                    <div class="custom-key">
                        <input type="text" id="custom-key" class="key-input" placeholder="Enter custom key for encoding...">
                        <button class="generate-key" id="generate-key">
                            <i class="fas fa-dice"></i>
                            <span>Generate Key</span>
                        </button>
                    </div>
                </div>
                
                <button id="process-btn">
                    <i class="fas fa-bolt"></i>
                    <span>Process</span>
                </button>
            </div>
            
            <div class="card output-section">
                <div class="result-header">
                    <h2><i class="fas fa-result"></i> Result</h2>
                    <div class="char-count" id="char-count">0 characters</div>
                </div>
                
                <div class="result" id="result-output">
                    Your encoded or decoded result will appear here...
                </div>
                
                <div class="encoding-info" id="encoding-info">
                    <strong>Custom Algorithm 1</strong> - Uses character substitution with custom mapping and bit manipulation. Cannot be decoded by standard tools.
                </div>
                
                <div class="action-buttons">
                    <button class="copy-btn" id="copy-result">
                        <i class="far fa-copy"></i>
                        <span>Copy to Clipboard</span>
                    </button>
                    <button class="download-btn" id="download-result">
                        <i class="fas fa-download"></i>
                        <span>Download as File</span>
                    </button>
                    <button class="clear-btn" id="clear-all">
                        <i class="fas fa-broom"></i>
                        <span>Clear All</span>
                    </button>
                </div>
            </div>
            
            <div class="security-note">
                <h3><i class="fas fa-shield-alt"></i> Custom Encoding Notice</h3>
                <p>This tool uses proprietary encoding algorithms that cannot be decoded by standard tools. Keep your custom key secure for maximum privacy.</p>
            </div>
        </main>
        
        <footer>
            <p>Custom Encoder Tool | Proprietary Algorithms | Secure Encoding</p>
        </footer>
    </div>
    
    <div class="notification" id="notification">Operation completed successfully!</div>
    
    <script>
        // DOM Elements
        const inputText = document.getElementById('input-text');
        const fileInput = document.getElementById('file-input');
        const fileName = document.getElementById('file-name');
        const encodingType = document.getElementById('encoding-type');
        const actionType = document.getElementById('action-type');
        const customKey = document.getElementById('custom-key');
        const generateKeyBtn = document.getElementById('generate-key');
        const processBtn = document.getElementById('process-btn');
        const resultOutput = document.getElementById('result-output');
        const charCount = document.getElementById('char-count');
        const encodingInfo = document.getElementById('encoding-info');
        const copyBtn = document.getElementById('copy-result');
        const downloadBtn = document.getElementById('download-result');
        const clearBtn = document.getElementById('clear-all');
        const notification = document.getElementById('notification');
        
        // Current state
        let currentResult = '';
        let currentFileName = '';
        
        // Encoding information
        const encodingDetails = {
            custom1: "Custom Algorithm 1 - Uses character substitution with custom mapping and bit manipulation. Cannot be decoded by standard tools.",
            custom2: "Custom Algorithm 2 - Implements a multi-layer encoding with position-based character shifting and XOR operations.",
            custom3: "Custom Algorithm 3 - Combines multiple encoding techniques with a custom substitution table and dynamic key integration.",
            matrix: "Matrix Encoding - Uses a grid-based transformation system that rearranges text in a non-standard pattern.",
            shadow: "Shadow Code - Implements a dual-layer encoding where characters are split and rearranged with control characters."
        };
        
        // Update encoding info when type changes
        encodingType.addEventListener('change', () => {
            const type = encodingType.value;
            encodingInfo.innerHTML = `<strong>${type.charAt(0).toUpperCase() + type.slice(1).replace(/([A-Z])/g, ' $1')}</strong> - ${encodingDetails[type]}`;
        });
        
        // Generate random key
        generateKeyBtn.addEventListener('click', () => {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
            let key = '';
            for (let i = 0; i < 16; i++) {
                key += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            customKey.value = key;
            showNotification('Custom key generated');
        });
        
        // File input handling
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                fileName.textContent = `Selected file: ${file.name} (${formatFileSize(file.size)})`;
                currentFileName = file.name;
                
                // Read file as text and populate input
                const reader = new FileReader();
                reader.onload = function(e) {
                    inputText.value = e.target.result;
                    updateCharCount();
                };
                reader.readAsText(file);
            }
        });
        
        // Update character count
        inputText.addEventListener('input', updateCharCount);
        
        function updateCharCount() {
            const count = inputText.value.length;
            charCount.textContent = `${count} characters`;
        }
        
        // Process button click
        processBtn.addEventListener('click', processData);
        
        // Copy result
        copyBtn.addEventListener('click', () => {
            if (!currentResult) {
                showNotification('No result to copy', true);
                return;
            }
            
            navigator.clipboard.writeText(currentResult)
                .then(() => {
                    showNotification('Result copied to clipboard');
                })
                .catch(err => {
                    showNotification('Failed to copy result', true);
                });
        });
        
        // Download result
        downloadBtn.addEventListener('click', () => {
            if (!currentResult) {
                showNotification('No result to download', true);
                return;
            }
            
            let filename = 'encoded_result.txt';
            if (currentFileName) {
                const extIndex = currentFileName.lastIndexOf('.');
                if (extIndex !== -1) {
                    filename = currentFileName.substring(0, extIndex) + '_' + 
                              (actionType.value === 'encode' ? 'encoded' : 'decoded') + '.txt';
                } else {
                    filename = currentFileName + '_' + 
                              (actionType.value === 'encode' ? 'encoded' : 'decoded') + '.txt';
                }
            }
            
            downloadFile(currentResult, filename);
            showNotification('File downloaded successfully');
        });
        
        // Clear all
        clearBtn.addEventListener('click', () => {
            inputText.value = '';
            resultOutput.textContent = 'Your encoded or decoded result will appear here...';
            fileInput.value = '';
            fileName.textContent = 'No file selected';
            currentResult = '';
            currentFileName = '';
            updateCharCount();
            showNotification('All fields cleared');
        });
        
        // Process data based on selected options
        function processData() {
            const input = inputText.value.trim();
            if (!input) {
                showNotification('Please enter some text or select a file', true);
                return;
            }
            
            const type = encodingType.value;
            const action = actionType.value;
            const key = customKey.value.trim();
            
            try {
                if (action === 'encode') {
                    currentResult = encodeData(input, type, key);
                } else {
                    currentResult = decodeData(input, type, key);
                }
                
                resultOutput.textContent = currentResult;
                showNotification(`${action === 'encode' ? 'Encoded' : 'Decoded'} successfully using ${type.replace(/([A-Z])/g, ' $1')}`);
            } catch (error) {
                showNotification(`Error: ${error.message}`, true);
            }
        }
        
        // Custom encoding functions
        function encodeData(data, type, key) {
            switch (type) {
                case 'custom1':
                    return customEncode1(data, key);
                case 'custom2':
                    return customEncode2(data, key);
                case 'custom3':
                    return customEncode3(data, key);
                case 'matrix':
                    return matrixEncode(data, key);
                case 'shadow':
                    return shadowEncode(data, key);
                default:
                    throw new Error('Unsupported encoding type');
            }
        }
        
        // Custom decoding functions
        function decodeData(data, type, key) {
            switch (type) {
                case 'custom1':
                    return customDecode1(data, key);
                case 'custom2':
                    return customDecode2(data, key);
                case 'custom3':
                    return customDecode3(data, key);
                case 'matrix':
                    return matrixDecode(data, key);
                case 'shadow':
                    return shadowDecode(data, key);
                default:
                    throw new Error('Unsupported encoding type');
            }
        }
        
        // Custom Algorithm 1 - Character substitution with bit manipulation
        function customEncode1(data, key) {
            // Create a custom substitution table
            const substitutionTable = createSubstitutionTable(key);
            let result = '';
            
            for (let i = 0; i < data.length; i++) {
                const char = data[i];
                const code = char.charCodeAt(0);
                
                // Apply bit manipulation
                const manipulated = (code ^ 0x55) + i;
                
                // Substitute using custom table
                const substituted = substitutionTable[manipulated % substitutionTable.length];
                
                result += substituted;
            }
            
            // Add prefix to identify encoding
            return '⍣' + result + '⍣';
        }
        
        function customDecode1(data, key) {
            // Remove prefix if present
            if (data.startsWith('⍣') && data.endsWith('⍣')) {
                data = data.substring(1, data.length - 1);
            }
            
            const substitutionTable = createSubstitutionTable(key);
            let result = '';
            
            for (let i = 0; i < data.length; i++) {
                const char = data[i];
                const index = substitutionTable.indexOf(char);
                
                if (index !== -1) {
                    // Reverse bit manipulation
                    const originalCode = (index - i) ^ 0x55;
                    result += String.fromCharCode(originalCode);
                } else {
                    result += char; // Keep character if not in substitution table
                }
            }
            
            return result;
        }
        
        // Custom Algorithm 2 - Multi-layer encoding
        function customEncode2(data, key) {
            let result = data;
            
            // Layer 1: Reverse string
            result = result.split('').reverse().join('');
            
            // Layer 2: Apply XOR with key
            const keyValue = key ? stringToNumber(key) : 12345;
            result = result.split('').map((char, i) => {
                return String.fromCharCode(char.charCodeAt(0) ^ (keyValue + i) % 256);
            }).join('');
            
            // Layer 3: Insert control characters
            let encoded = '';
            for (let i = 0; i < result.length; i++) {
                encoded += result[i];
                if (i % 3 === 2) {
                    encoded += String.fromCharCode(0x200B + (i % 10)); // Zero-width spaces
                }
            }
            
            return '⚡' + encoded + '⚡';
        }
        
        function customDecode2(data, key) {
            // Remove prefix if present
            if (data.startsWith('⚡') && data.endsWith('⚡')) {
                data = data.substring(1, data.length - 1);
            }
            
            // Remove control characters
            let result = data.replace(/[\u200B-\u200D\uFEFF]/g, '');
            
            // Reverse XOR with key
            const keyValue = key ? stringToNumber(key) : 12345;
            result = result.split('').map((char, i) => {
                return String.fromCharCode(char.charCodeAt(0) ^ (keyValue + i) % 256);
            }).join('');
            
            // Reverse string
            result = result.split('').reverse().join('');
            
            return result;
        }
        
        // Custom Algorithm 3 - Complex transformation
        function customEncode3(data, key) {
            // Create a shuffled character set based on key
            const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 !@#$%^&*()_+-=[]{}|;:,.<>?';
            const shuffled = shuffleString(charset, key);
            
            let result = '';
            for (let i = 0; i < data.length; i++) {
                const char = data[i];
                const index = charset.indexOf(char);
                
                if (index !== -1) {
                    // Use shuffled mapping
                    result += shuffled[index];
                } else {
                    // Keep character if not in charset
                    result += char;
                }
                
                // Insert separator every 4 characters
                if ((i + 1) % 4 === 0 && i < data.length - 1) {
                    result += '·';
                }
            }
            
            return '◈' + result + '◈';
        }
        
        function customDecode3(data, key) {
            // Remove prefix if present
            if (data.startsWith('◈') && data.endsWith('◈')) {
                data = data.substring(1, data.length - 1);
            }
            
            // Remove separators
            data = data.replace(/·/g, '');
            
            // Create shuffled character set (same as encoding)
            const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 !@#$%^&*()_+-=[]{}|;:,.<>?';
            const shuffled = shuffleString(charset, key);
            
            let result = '';
            for (let i = 0; i < data.length; i++) {
                const char = data[i];
                const index = shuffled.indexOf(char);
                
                if (index !== -1) {
                    // Reverse shuffled mapping
                    result += charset[index];
                } else {
                    // Keep character if not in shuffled set
                    result += char;
                }
            }
            
            return result;
        }
        
        // Matrix Encoding
        function matrixEncode(data, key) {
            // Convert to grid and transpose
            const gridSize = Math.ceil(Math.sqrt(data.length));
            let grid = [];
            
            // Fill grid with data
            for (let i = 0; i < gridSize; i++) {
                grid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    const index = i * gridSize + j;
                    grid[i][j] = index < data.length ? data[index] : '█';
                }
            }
            
            // Transpose grid
            let result = '';
            for (let j = 0; j < gridSize; j++) {
                for (let i = 0; i < gridSize; i++) {
                    result += grid[i][j];
                }
            }
            
            return '▦' + result + '▦';
        }
        
        function matrixDecode(data, key) {
            // Remove prefix if present
            if (data.startsWith('▦') && data.endsWith('▦')) {
                data = data.substring(1, data.length - 1);
            }
            
            const gridSize = Math.ceil(Math.sqrt(data.length));
            let grid = [];
            
            // Fill grid with transposed data
            for (let i = 0; i < gridSize; i++) {
                grid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    const index = j * gridSize + i;
                    grid[i][j] = index < data.length ? data[index] : '█';
                }
            }
            
            // Read original data from grid
            let result = '';
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const char = grid[i][j];
                    if (char !== '█') {
                        result += char;
                    }
                }
            }
            
            return result;
        }
        
        // Shadow Encoding
        function shadowEncode(data, key) {
            let result = '';
            
            for (let i = 0; i < data.length; i++) {
                const char = data[i];
                const code = char.charCodeAt(0);
                
                // Split character into two parts
                const high = (code >> 4) & 0x0F;
                const low = code & 0x0F;
                
                // Convert to custom characters
                result += String.fromCharCode(0x2580 + high);
                result += String.fromCharCode(0x2580 + low);
            }
            
            return '◐' + result + '◑';
        }
        
        function shadowDecode(data, key) {
            // Remove prefix if present
            if (data.startsWith('◐') && data.endsWith('◑')) {
                data = data.substring(1, data.length - 1);
            }
            
            let result = '';
            
            // Process pairs of characters
            for (let i = 0; i < data.length; i += 2) {
                if (i + 1 < data.length) {
                    const high = data[i].charCodeAt(0) - 0x2580;
                    const low = data[i + 1].charCodeAt(0) - 0x2580;
                    
                    // Reconstruct original character
                    const code = (high << 4) | low;
                    result += String.fromCharCode(code);
                }
            }
            
            return result;
        }
        
        // Utility functions
        function createSubstitutionTable(key) {
            // Create a custom character set for substitution
            let table = [];
            
            // Add various Unicode characters
            for (let i = 0x2000; i < 0x2070; i++) {
                table.push(String.fromCharCode(i));
            }
            
            // Add mathematical symbols
            for (let i = 0x2200; i < 0x2260; i++) {
                table.push(String.fromCharCode(i));
            }
            
            // Shuffle based on key
            if (key) {
                table = shuffleArray(table, key);
            }
            
            return table;
        }
        
        function shuffleArray(array, key) {
            const seed = stringToNumber(key);
            const rng = seededRandom(seed);
            
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            
            return array;
        }
        
        function shuffleString(str, key) {
            const arr = str.split('');
            return shuffleArray(arr, key).join('');
        }
        
        function stringToNumber(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0; // Convert to 32-bit integer
            }
            return Math.abs(hash);
        }
        
        function seededRandom(seed) {
            return function() {
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            };
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function downloadFile(content, filename) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function showNotification(message, isError = false) {
            notification.textContent = message;
            notification.className = 'notification';
            
            if (isError) {
                notification.classList.add('error');
            }
            
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        // Initialize
        updateCharCount();
    </script>
</body>
</html>
